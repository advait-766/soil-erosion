import numpy as np
import math
import sys
import os

import main_src.constants                           as constants
from   main_src.tools.resolve_partial_computing import *
from   main_src.tools.tools                     import comp_type
import main_src.flow_algorithm.flow_direction       as flow_direction
import main_src.flow_algorithm.mfd                  as mfd
import main_src.flow_algorithm.D8                   as D8_
import main_src.stream_functions.stream_f           as stream_f
import main_src.processes.rill                 as rill
import main_src.processes.surface              as surface
import main_src.processes.subsurface           as darcy
import main_src.io_functions.prt               as prt




isRill, subflow, stream, diffuse = comp_type()


prt.message("--------------------- The computing setup ---------------------")


## Documentation for a class.
#
#  method to compute size of class arrays
class Size:

  ## size
  #  @param arrayNBytes <numpy array>.nbytes
  #  @param m value in denominator to get bytes, kilobytes (m=2**10), megabytes (m=2**10+m**10) and so on.
  def size(self, arrayNBytes, m=1.0):
    # arrayNBytes eq self.state.nbytes
    size = (self.n * arrayNBytes)/m
    return size





class Globals:
  pixel_area = pixel_area
  r        = rows
  c        = cols
  rr    = rrows
  rc    = rcols
  br    = boundaryRows
  bc    = boundaryCols
  xllcorner = x_coordinate
  yllcorner = y_coordinate
  NoDataValue = NoDataValue
  NoDataInt   = int(-9999)
  dx = math.sqrt(pixel_area)
  dy = dx
  type_of_computing = type_of_computing



class D8(object):

  def __init__(self):
    prt.message("\tD8 flow algorithm")
    self.inflows = D8_.new_inflows(mat_fd)

  def update_inflows(self,fd):
    self.inflows = D8_.new_inflows(fd)


  def cell_runoff(self,i,j,sur=True):
    inflow_from_cells = 0.0
    for z in range(len(self.inflows[i][j])):
      ax = self.inflows[i][j][z][0]
      bx = self.inflows[i][j][z][1]
      iax = i+ax
      jbx = j+bx
      try:
        insurfflow_from_cell = self.arr[iax][jbx].V_runoff_pre
      except:
        insurfflow_from_cell = 0.0
      try:
        inrillflow_from_cell = self.arr[iax][jbx].V_runoff_rill_pre
      except:
        inrillflow_from_cell = 0.0
      inflow_from_cells = inflow_from_cells + insurfflow_from_cell + inrillflow_from_cell


    return inflow_from_cells




class Mfda(object):

  def __init__(self):
    prt.message("\tMultiflow direction algorithm")
    self.inflows, fd_rill  = mfd.new_mfda(mat_dmt, mat_nan, mat_fd, vpix, spix, rows, cols)
    self.inflowsRill       =  D8_.new_inflows(fd_rill)

  def update_inflows(self,fd):
    self.inflows, fd_rill   = mfd.new_mfda(self.H, mat_nan, fd, vpix, spix, rows, cols)
    self.inflowsRill        = D8_.new_inflows(fd_rill)

  def cell_runoff(self,i,j,sur=True):


    inflow_from_cells = \
      self.inflows[i-1][j-1][1]*self.V_runoff_pre[i-1][j-1]+\
        self.inflows[i-1][j][2]*self.V_runoff_pre[i-1][j]+\
          self.inflows[i-1][j+1][3]*self.V_runoff_pre[i-1][j+1]+\
            self.inflows[i][j-1][0]*self.V_runoff_pre[i][j-1]+\
              self.inflows[i][j+1][4]*self.V_runoff_pre[i][j+1]+\
                self.inflows[i+1][j-1][7]*self.V_runoff_pre[i+1][j-1]+\
                  self.inflows[i+1][j][6]*self.V_runoff_pre[i+1][j]+\
                    self.inflows[i+1][j+1][5]*self.V_runoff_pre[i+1][j+1]


    if isRill and sur:
      for z in range(len(self.inflowsRill[i][j])):
        ax = self.inflowsRill[i][j][z][0]
        bx = self.inflowsRill[i][j][z][1]
        iax = i+ax
        jbx = j+bx
        if (self.state[i][j] == 1) or (self.state[i][j] == 2) : # rill
          try:
            inflow_from_cells += self.V_runoff_rill_pre[iax][jbx] #toto jeste predelat u ryh
          except:
            inrillflow_from_cell += 0.0


    return inflow_from_cells







class Kinematic(Mfda if mfda==True else D8):

  def __init__(self):
    prt.message("\tKinematic approach")
    super(Kinematic, self).__init__()
    self.H = mat_dmt

  def new_inflows(self):
    pass

  def update_H(self):
    pass








class Diffuse(Mfda if mfda==True else D8, Globals):

  def __init__(self):
    prt.message("\tDiffuse approach")
    if (Globals.r == None or Globals.r == None):
      exit("Global variables are not assigned")
    r = self.r
    c = self.c

    self.H = np.zeros([r,c],float)

  def new_inflows(self):
    fd = flow_direction.flow_direction(self.H,self.rr,self.rc,self.br,self.bc,self.pixel_area)
    self.inflows = self.update_inflows(fd)


  def update_H(self):

    arr = self.arr[i][j]

    for i in self.rr:
      for j in self.rc[i]:
	arr.H = arr.h + arr.z
    for i in self.rr:
      for j in self.rc[i]:
        arr.slope = self.slope_(i,j)





class VegArrs:
  def __init__(self,veg_true,ppl,pi):
    self.veg_true = veg_true
    self.ppl      = ppl
    self.pi       = pi


## Documentation for a class.
#  More details.
#
class Vegetation(Globals,Size):


  ## The constructor.
  def __init__(self,mat_ppl,mat_pi):

    if (Globals.r == None or Globals.r == None):
      exit("Global variables are not assigned")

    self.n = 3
    self.arr = np.empty((self.r,self.c), dtype=object)

    for i in range(self.r):
      for j in range(self.c):
        self.arr[i][j] = VegArrs(0,mat_ppl[i][j],mat_pi[i][j])






class Reach():

  def __init__(self,id_,POINT_X,POINT_Y,POINT_X_1,POINT_Y_1,to_node,length,sklon,smoderp,CISLO,TVAR,B,M,DRSNOST,Q365):

    #TVAR = 1
    #print '\n!\n!\n!\ntvar je na tvrdo 1'
    #raw_input('classes_main_arrays 299\n!\n!\n!')

    self.id_ = id_
    ##self.imat = i  #jj melo byt pozice v matici, ale to mozna nani treba kdyz zanech mat_tok_usek a tam id useku
    ##self.jmat = j
    self.pointsFrom = [POINT_X,POINT_Y]
    self.pointsTo   = [POINT_X_1,POINT_Y_1]
    self.to_node = to_node
    self.length = length
    if sklon < 0:
        prt.message("Slope in reach part"+str(id)+"indicated minus slope in stream")
    self.slope = abs(sklon)
    self.smoderp = smoderp
    self.no = CISLO
    self.shape = TVAR

    self.b = B
    self.m = M
    self.roughness = DRSNOST
    self.Q365 = Q365
    self.V_in_from_field = 0.0
    self.V_in_from_field_cum = 0.0
    self.V_in_from_reach = 0.0
    self.V_out_cum = 0.0   # L^3
    self.V_rest = 0.0
    self.h    = 0.0     #jj mozna pocatecni podminka? ikdyz to je asi Q365 co...
    self.h_max    = 0.0
    self.timeh_max    = 0.0
    self.V_out    = 0.0
    self.vs      = 0.0
    self.Q_out   = 0.0
    self.Q_max   = 0.0
    self.timeQ_max   = 0.0
    self.V_out_domain = 0.0

    if TVAR == 1 :    #obdelnik
      self.outflow_method = stream_f.rectangle
    elif TVAR == 0 :  #trapezoid
      self.outflow_method = stream_f.trapezoid
    elif TVAR == 2 :  #triangle
      self.outflow_method = stream_f.triangle
    elif TVAR == 3 :  #parabola
      self.outflow_method = stream_f.parabola




## Documentation for a class.
#
#  More details.

# Bacha na id, je id v shp toku v sestupnem poradi. To musi jinak bude chyba ve tvorbe reach
class Stream(object,Globals):

  ## The constructor.
  def __init__(self):
    #jj
    prt.message('Stream:')
    prt.message('\tON')
    super(Stream, self).__init__()

    # pak kouknout co je treba jen uvnitr tridy
    #self.temp_dp = sp.temp_dp

    # listy v poradi 'FID' 'POINT_X' 'POINT_Y' 'POINT_X_1' 'POINT_Y_1' 'to_node' 'length' 'sklon' 'smoderp' 'CISLO' 'TVAR' 'B' 'M' 'DRSNOST' 'Q365'
    self.toky = toky # tu jsou nactena data z data preparation cca lajna 970

    self.nReaches = len(toky[0])
    self.cell_stream = cell_stream

    self.reach = []
    
    for i in range(self.nReaches):
      self.reach.append(Reach(toky[0][i],toky[1][i],toky[2][i],toky[3][i],toky[4][i],toky[5][i],toky[6][i],toky[7][i],toky[8][i],toky[9][i],toky[10][i],toky[11][i],toky[12][i],toky[13][i],toky[14][i]))

    self.tokyLoc      = tokyLoc
    self.mat_tok_usek = mat_tok_usek
    for i in self.rr :
      for j in self.rc[i]:
        self.arr[i][j].state += mat_tok_usek[i][j]

    self.STREAM_RATIO = STREAM_RATIO


  def reset_inflows(self):
    for id_ in range(self.nReaches):
      self.reach[id_].V_in_from_field = 0
      

  ## Documentation for a reach inflows.
  #  @param id_ starts in 0 not 1000
  def reach_inflows(self,id_, inflows):
    self.reach[id_].V_in_from_field += inflows

  def stream_reach_outflow(self,dt):
    for id_ in range(self.nReaches):
      self.reach[id_].outflow_method(self.reach[id_],dt)


  def stream_reach_inflow(self):
    for id_ in range(self.nReaches):
      self.reach[id_].V_in_from_reach = 0
      self.reach[id_].V_out_domain    = 0
      
    for id_ in range(self.nReaches):
      id_to_node = int(self.reach[id_].to_node)
      if id_to_node == -9999:
        self.reach[id_].V_out_domain += self.reach[id_].V_out
      else:
        self.reach[id_to_node].V_in_from_reach += self.reach[id_].V_out


  #jj jeste dodelat ty maxima a kumulativni zbyle
  def stream_cumulative(self,time):
    for id_ in range(self.nReaches):
      self.reach[id_].V_out_cum += self.reach[id_].V_out
      self.reach[id_].V_in_from_field_cum += self.reach[id_].V_in_from_field
      if self.reach[id_].Q_out > self.reach[id_].Q_max:
        self.reach[id_].Q_max = self.reach[id_].Q_out
        self.reach[id_].timeQ_max        = time
      if self.reach[id_].h > self.reach[id_].h_max:
        self.reach[id_].h_max = self.reach[id_].h
        self.reach[id_].timeh_max        = time
        
        
  def return_stream_str_vals(self,i,j,sep,dt):
    id_ = int(self.arr[i][j].state-1000)
    # Time;   V_runoff  ;   Q   ;    V_from_field  ;  V_rests_in_stream
    print id_
    line = str(self.reach[id_].h) +sep+str(self.reach[id_].V_out) +sep+ str(self.reach[id_].Q_out) + sep + \
      str(self.reach[id_].V_in_from_field) + sep + str(self.reach[id_].V_rest)
    return line







class StreamPass(object):
  def __init__(self):
    super(StreamPass, self).__init__()
    prt.message('Stream:')
    prt.message('\tOFF')
  def reset_inflows(self):
    pass
  def reach_inflows(self,id_, inflows):
    pass

  def stream_reach_inflow(self):
    pass

  def stream_reach_outflow(self,dt):
    pass

  #jj jeste dodelat ty maxima a kumulativni zbyle
  def stream_cumulative(self,dt):
    pass





class SurArrs :

  def __init__(self,sur_ret,inf_index, hcrit, a, b):

    self.state =     int(0)
    self.sur_ret =   sur_ret
    self.cur_sur_ret = float(0)
    self.h =           float(0)
    self.h_total =     float(0)
    self.h_total_pre =    float(0)
    self.V_runoff =     float(0)
    self.V_runoff_pre = float(0)
    self.V_rest =       float(0)
    self.V_rest_pre =   float(0)
    self.inflow_tm =    float(0)
    self.soil_type =    inf_index
    self.infiltration = float(0)
    self.h_crit =       hcrit
    self.a =            a
    self.b =            b
    self.h_rill =       float(0)
    self.h_rillPre =    float(0)
    self.V_runoff_rill= float(0)
    self.V_runoff_rill_pre= float(0)
    self.V_rill_rest =      float(0)
    self.V_rill_rest_pre =  float(0)
    self.rillWidth   =      float(0)



## Documentation for a class Surface.
#  Class Surface contains the data about the surface and fill runoff
#
class Surface(Stream if stream == True else StreamPass,Kinematic,Globals,Size):


  ## The constructor
  #  make all numpy arrays and establish the inflow procedure based on D8 or Multi Flow Direction Algorithm method
  def __init__(self,sur_ret,mat_inf_index,mat_hcrit,mat_aa,mat_b):

    prt.message("Surface:")

    self.n = 15
    self.arr = np.empty((self.r,self.c), dtype=object)

    for i in range(self.r):
      for j in range(self.c):
        self.arr[i][j] = SurArrs(sur_ret,mat_inf_index[i][j],mat_hcrit[i][j],mat_aa[i][j],mat_b[i][j])

    self.rill_computing          = isRill
    self.shallowSurfaceKinematic = surface.shallowSurfaceKinematic
    self.rillCalculations        = rill.rillCalculations

    if (isRill) :
      prt.message("\tRill flow: \n\t\tON")
      self.runoff = self.__runoff
    else:
      prt.message("\tRill flow: \n\t\tOFF")
      self.runoff = self.__runoff_zero_compType

    super(Surface, self).__init__()



  ## Calculates the sheet and rill flow.
  #
  def __runoff(self,i,j,dt,efect_vrst,ratio) :

    #prt.debug(i==30 and j==30, "V_in_total", self.arr[i][j].h*self.pixel_area)

    self.update_state(i,j)
    self.compute_h_hrill(i,j)


    #prt.debug(i==30 and j==30, "V_in_sheet", self.arr[i][j].h*self.pixel_area)
    #prt.debug(i==30 and j==30, "V_in_rill",  self.arr[i][j].h_rill*self.pixel_area,'\n')

    q_sheet = self.sheet_runoff(i,j,dt)

    if self.arr[i][j].h> 0.0 :
      v_sheet = q_sheet / (self.arr[i][j].h*efect_vrst)
    else:
      v_sheet = 0.0

    #prt.debug(i==30 and j==30, "b pred", self.arr[i][j].rillWidth)

    if self.arr[i][j].state > 0 :
      q_rill, v_rill, ratio, rill_courant = self.rill_runoff(i,j,dt,efect_vrst,ratio)
    else:
      q_rill, v_rill, ratio, rill_courant = 0, 0, ratio, 0.4

    #prt.debug(i==30 and j==30, "b po  ",  self.arr[i][j].rillWidth,'\n')
    #prt.debug(i==30 and j==30, "V_runoff", self.arr[i][j].V_runoff)
    #prt.debug(i==30 and j==30, "V_rest",   self.arr[i][j].V_rest,'\n')
    #prt.debug(i==30 and j==30, "V_rill_runoff", self.arr[i][j].V_runoff_rill)
    #prt.debug(i==30 and j==30, "V_rest_rill",   self.arr[i][j].V_rill_rest,'\n')
    #prt.debug(i==30 and j==30, 'OUT',  self.arr[i][j].V_runoff+self.arr[i][j].V_runoff_rill)
    #prt.debug(i==30 and j==30, 'REST', self.arr[i][j].V_rest+  self.arr[i][j].V_rill_rest)
    #prt.debug(i==30 and j==30, '------------')

    return q_sheet, v_sheet, q_rill, v_rill, ratio, rill_courant


  def __runoff_zero_compType(self,i,j,dt,efect_vrst,ratio) :

    arr = self.arr[i][j]
    """
    prt.debug(i==30 and j==30, "V_in", self.arr[i][j].h*self.pixel_area)
    prt.debug(i==30 and j==30, "V_in_sheet", self.arr[i][j].h*self.pixel_area)
    prt.debug(i==30 and j==30, "V_in_rill",  self.arr[i][j].h_rill*self.pixel_area,'\n')
    """
    q_sheet = self.shallowSurfaceKinematic(arr)
    arr.V_runoff = dt * q_sheet * self.dx
    arr.V_rest = arr.h * self.pixel_area - arr.V_runoff
    if arr.h > 0.0 :
      v_sheet = q_sheet / (arr.h*efect_vrst)
    else:
      v_sheet = 0.0
    q_rill = 0
    v_rill = 0

    self.arr[i][j] = arr

    """
    prt.debug(i==30 and j==30, "V_runoff", self.arr[i][j].V_runoff)
    prt.debug(i==30 and j==30, "V_rest",   self.arr[i][j].V_rest,'\n')
    prt.debug(i==30 and j==30, "V_rill_runoff", self.arr[i][j].V_runoff_rill)
    prt.debug(i==30 and j==30, "V_rest_rill",   self.arr[i][j].V_rill_rest,'\n')
    prt.debug(i==30 and j==30, 'OUT',  self.arr[i][j].V_runoff+self.arr[i][j].V_runoff_rill)
    prt.debug(i==30 and j==30, 'REST', self.arr[i][j].V_rest+  self.arr[i][j].V_rill_rest)
    prt.debug(i==30 and j==30, '------------')
    """

    return q_sheet, v_sheet, q_rill, v_rill, ratio


  def update_state(self,i,j):

    ht    = self.arr[i][j].h
    ht_1  = self.arr[i][j].h_total_pre
    hcrit = self.arr[i][j].h_crit
    state = self.arr[i][j].state

    err = 0 #
    err = 1e-3
    if ht>=hcrit :
      if state == 0:
        state = 1
      elif state == 1 :
        if ht>=(ht_1-err) :
          pass
        else :
          state = 2

      elif state == 2:
        if ht>=(ht_1-err)      :
          state = 1
        else :
          pass
    else:
      if state==1 :
        state = 2

    self.arr[i][j].state = state


  def compute_h_hrill(self,i,j):

    arr = self.arr[i][j]

    state = arr.state
    #if i==6 and j==3 : print state, 'h', self.h
    if state == 0 :
      arr.h_rill = 0
    elif state == 1 :
      arr.h_rill = arr.h - arr.h_crit
      arr.h      = arr.h_crit
      arr.h_rillPre = arr.h_rill
    elif state == 2 :


      arr.h_rill = arr.h_rillPre

      if (arr.h_rill < arr.h) :
        arr.h      = arr.h - arr.h_rill
      else:
        arr.h_rill = max(arr.h,0)
        arr.h      = 0.0


  def sheet_runoff(self,i,j,dt):
    #jj h musi byt aktualni v self.h !!!!

    arr = self.arr[i][j]

    q_sheet = self.shallowSurfaceKinematic(arr)
    arr.V_runoff = dt * q_sheet * self.dx
    arr.V_rest = arr.h * self.pixel_area - arr.V_runoff

    #self.arr[i][j] = arr

    return q_sheet

  def rill_runoff(self,i,j,dt,efect_vrst,ratio):

    arr = self.arr[i][j]
    #print self.h_crit[i][j], self.h_rill[i][j]
    arr.rillWidth, arr.V_runoff_rill,\
    arr.V_rill_rest, q_rill,v_rill, ratio, rill_courant = self.rillCalculations(arr,self.pixel_area,
                                                                      efect_vrst,
                                                                      constants.RILL_RATIO,
                                                                      mat_n[i][j],
                                                                      mat_slope[i][j],
                                                                      dt,
                                                                      ratio)



    arr.h_rill = arr.V_rill_rest/self.pixel_area


    return q_rill, v_rill, ratio, rill_courant

  def bilance(self):
    pass

  def surface_retention(self,i,j,bil):

    reten = self.arr[i][j].sur_ret
    pre_reten = reten
    if reten < 0:
      tempBIL = bil + reten

      if tempBIL > 0:
        bil = tempBIL
        reten = 0
      else:
        reten = tempBIL
        bil = 0
    self.arr[i][j].sur_ret = reten
    self.arr[i][j].cur_sur_ret = reten-pre_reten

    return bil

  def return_str_vals(self,i,j,sep,dt):

    arr = self.arr[i][j]

    #Water_level_[m];Flow_[m3/s];V_runoff[m3];V_rest[m3];Infiltration[];surface_retention[l]
    line = str(arr.h) + sep + str(arr.V_runoff/dt) + sep + str(arr.V_runoff) + sep + str(arr.V_rest) + sep + str(arr.infiltration)+ sep + str(arr.cur_sur_ret)+ sep + str(arr.state) + sep + str(arr.inflow_tm)

    if self.rill_computing :
      #';Rill_size;Rill_flow;Rill_V_runoff;Rill_V_rest'
      line += sep + str(arr.h_rill) + sep + str(arr.rillWidth) + sep + str(arr.V_runoff_rill/dt) + sep + str(arr.V_runoff_rill) + sep + str(arr.V_rill_rest) + sep + str(arr.V_runoff/dt + arr.V_runoff_rill/dt) + sep + str(arr.V_runoff+arr.V_runoff_rill)
    bil_  = arr.inflow_tm - arr.V_runoff - arr.V_runoff_rill - arr.cur_sur_ret*self.pixel_area - arr.V_rest + arr.V_rest_pre - arr.infiltration*self.pixel_area - arr.V_rill_rest + arr.V_rill_rest_pre
    return line, bil_






class SubArrs:

  def __init__(self, L_sub, Ks, vg_n, vg_l, z):
    self.L_sub =     L_sub
    self.h =         float(0)
    self.H =         float(0)
    self.z =         z
    self.slope =      float(0)
    self.exfiltration = float(0)
    self.V_runoff =     float(0)
    self.V_runoff_pre = float(0)
    self.V_rest =       float(0)
    self.Ks =           Ks
    self.cum_percolation =   float(0)
    self.percolation  =   float(0)
    self.vg_n =   vg_n
    self.vg_m =   1.0-1.0/vg_n
    self.vg_l =   vg_l



## Documentation for a class.
#  More details.
#
class SubsurfaceC(Diffuse if diffuse == True else Kinematic, Size,Globals):
  def __init__(self,L_sub, Ks, vg_n, vg_l):

    if (Globals.r == None or Globals.r == None):
      exit("Global variables are not assigned")
    super(SubsurfaceC, self).__init__()

    r = self.r
    c = self.c

    self.arr = np.empty((self.r,self.c), dtype=object)

    for i in range(self.r):
      for j in range(self.c):
        self.arr[i][j] = SubArrs(L_sub, Ks, vg_n, vg_l,mat_dmt[i][j]-L_sub)


    for i in self.rr:
      for j in self.rc[i]:
        self.arr[i][j].slope = self.slope_(i,j)

    self.Kr    = darcy.relative_unsat_conductivity
    self.darcy = darcy.darcy

  def slope_(self,i,j):
    a = self.arr[i-1][j-1].H
    b = self.arr[i-1][j].H
    c = self.arr[i-1][j+1].H
    d = self.arr[i][j-1].H
    f = self.arr[i][j+1].H
    g = self.arr[i+1][j-1].H
    h = self.arr[i+1][j].H
    k = self.arr[i+1][j+1].H
    dzdx = ((c + 2.0*f + k) - (a + 2.0*d + g))/(8.0 * self.pixel_area)
    dzdy = ((g + 2.0*h + k) - (a + 2.0*b + c))/(8.0 * self.pixel_area)
    nasobek = math.sqrt(pow(dzdx,2) + pow(dzdy,2))
    diffslope = math.atan(nasobek) * math.pi/180

    return diffslope

  def fill_slope(self):
    self.update_H()

  def get_exfiltration(self,i,j):
    return self.arr[i][j].exfiltration

  def bilance(self,i,j,infilt,inflow,dt):

    arr = self.arr[i][j]

    bil = infilt + arr.V_rest/self.pixel_area + inflow
    percolation  = self.calc_percolation(i,j,bil,dt)
    arr.cum_percolation += percolation
    bil -= percolation
    arr.percolation = percolation
    arr.h, arr.exfiltration = self.calc_exfiltration(i,j,bil)

  def calc_percolation(self,i,j,bil,dt):

    arr = self.arr[i][j]

    if (bil > arr.L_sub):
      S = 1.0
    else:
      S = bil/arr.L_sub
    perc = arr.Ks*self.Kr(S,arr.vg_l,arr.vg_m)*dt
    if (perc > bil):
      perc = bil
    return perc

  def calc_exfiltration(self,i,j,bil):

    arr = self.arr[i][j]

    if (bil > arr.L_sub):
      bil = arr.L_sub
      exfilt  = bil-arr.L_sub
    else:
      exfilt = 0
    return bil,exfilt

  def runoff(self,i,j,delta_t,efect_vrst):

    arr = self.arr[i][j]

    self.q_subsurface = self.darcy(arr,efect_vrst)
    arr.V_runoff = delta_t * self.q_subsurface
    arr.V_rest = arr.h * self.pixel_area - delta_t * self.q_subsurface

  def runoff_stream_cell(self,i,j):
    self.arr[i][j].V_runoff = 0.0
    self.arr[i][j].V_rest   = 0.0
    return self.arr[i][j].h

  def curr_to_pre(self):
    for i in self.rr:
      for j in self.rc[i]:
        self.arr[i][j].V_runoff_pre = self.arr[i][j].V_runoff

  def return_str_vals(self,i,j,sep,dt):
    arr = self.arr[i][j]
     #';Sub_Water_level_[m];Sub_Flow_[m3/s];Sub_V_runoff[m3];Sub_V_rest[m3];Percolation[],exfiltration[];'
    line = sep + str(arr.h) + sep + str(arr.V_runoff/dt) + sep + str(arr.V_runoff) + sep + str(arr.V_runoff) + sep + str(arr.percolation) + sep + str(arr.exfiltration)
    return line




## Class
#  empty class if no subsurface flow is considered
class SubsurfacePass(object,Size,Globals):
  def __init__(self,L_sub, Ks, vg_n, vg_l):
    #jj
    self.n = 0
    self.arr = np.empty((self.r,self.c), dtype=object)
    self.q_subsurface = None
    #self.arr = np.zeros([0],float)
    prt.message("\tOFF")
  def new_inflows(self):
    pass
  def cell_runoff(self,i,j,sur):
    pass
  def fill_slope(self):
    pass
  def get_exfiltration(self,i,j):
    return 0.0
  def bilance(self,i,j,infilt,inflow,dt):
    pass
  def runoff(self,i,j,delta_t,efect_vrst):
    pass
  def runoff_stream_cell(self,i,j):
    return 0.0
  def return_str_vals(self,i,j,sep,dt):
    return ''
  def curr_to_pre(self):
    pass



class Subsurface(SubsurfaceC if subflow == True else SubsurfacePass):
  def __init__(self,L_sub = 0.025, Ks = 0.05, vg_n = 1.5, vg_l =  0.5):
    prt.message("Subsurface:")
    super(Subsurface, self).__init__(L_sub = 0.025, Ks = 0.05, vg_n = 1.5, vg_l =  0.5)



class CumulativeSubsurface(object):

  def __init__(self):


    prt.message('\tSubsurface')
    super(CumulativeSubsurface, self).__init__()


    self.arrs[14] = 'exfiltration'
    self.arrs[15] = 'percolation'
    self.arrs[16] = 'h_sub'
    self.arrs[17] = 'q_sub'
    self.arrs[18] = 'V_sub'



    self.names[14] = 'CumExfiltrL3'
    self.names[15] = 'CumPercolL3'
    self.names[16] = 'MaxWaterSubL'
    self.names[17] = 'MaxQSubL3t_1'
    self.names[18] = 'CumVOutSubL3'



    r = self.r
    c = self.c

    self.n += 0
    self.exfiltration      =  np.zeros([r,c],float)
    self.percolation      =  np.zeros([r,c],float)
    self.h_sub      =  np.zeros([r,c],float)
    self.q_sub      =  np.zeros([r,c],float)
    self.V_sub      =  np.zeros([r,c],float)

  def update_cumulative_sur(self,i,j,sub,q_subsur):



    self.exfiltration[i][j] += sub.exfiltration*self.pixel_area
    self.percolation[i][j] += sub.percolation*self.pixel_area
    self.V_sub[i][j] += sub.V_runoff

    if sub.h > self.h_sub[i][j]:
      self.h_sub[i][j] = sub.h
    if q_subsur > self.q_sub[i][j]:
      self.q_sub[i][j] = q_subsur

class CumulativeSubsurfacePass(object):
  def update_cumulative_sur(self,i,j,sub,q_subsur):
    pass




## Max and Cumulative values
#
#  Stores array of max or cumulative values at of important variables Asi dame do Surface
#  u podpovrchu to tak bude
class Cumulative(CumulativeSubsurface if subflow == True else CumulativeSubsurfacePass, Globals,Size):




  ## the constructor
  #  sadfasdfasdfasdfasdfasdfa asdf
  #
  def __init__(self):
    prt.message('Save cumulative and maximum values from:')
    prt.message('\tSurface')
    # jj tady jsou jmena areju si je ta trida pamatuje
    self.arrs = {1  : 'infiltration',
            2  : 'precipitation',
            3  : 'h_sur',
            4  : 'q_sur',
            5  : 'V_sur',
            6  : 'v_sur',
            7  : 'shear_sur',
            8  : 'h_rill',
            9  : 'q_rill',
            10 : 'V_rill',
            11 : 'b_rill',
            12 : 'inflow_sur',
            13 : 'sur_ret'
            }

            #12 : 'v_rill',

    # jj tady jsou jmena areju jak je to lidsky vystiznejsi (nebo ne?)
    self.names = {1  : 'CumInfiltL',
            2  : 'CumRainL',
            3  : 'MaxWateL',
            4  : 'MaxQL3t_1',
            5  : 'CumVOutL3',
            6  : 'MaxVelovity',
            7  : 'ShearStress',
            8  : 'MaxWaterRillL',
            9  : 'MaxQRillL3t_1',
            10 : 'CumVOutRillL3',
            11 : 'AreaRill',
            12 : 'CumVInL3',
            13 : 'SurRet'
            }
            #12 : 'MaxVeloRill',

    if (Globals.r == None or Globals.r == None):
      sys.exit("Global variables are not assigned")

    r = self.r
    c = self.c

    self.n = 13
    self.infiltration  =  np.zeros([r,c],float)
    self.infiltrationName  =  'Infiltration'

    self.precipitation =  np.zeros([r,c],float)
    self.precipitationName = 'Precipitation'


    ##  \b h0 \n
    #  tady muzen data popis k h
    self.h_sur  =  np.zeros([r,c],float)
    self.q_sur  =  np.zeros([r,c],float)
    self.V_sur  =  np.zeros([r,c],float)
    self.v_sur  =  np.zeros([r,c],float)
    self.shear_sur  =  np.zeros([r,c],float)
    self.inflow_sur  =  np.zeros([r,c],float)
    self.h_rill =  np.zeros([r,c],float)
    self.q_rill =  np.zeros([r,c],float)
    self.V_rill =  np.zeros([r,c],float)
    self.b_rill =  np.zeros([r,c],float)
    self.v_rill =  np.zeros([r,c],float)
    self.sur_ret=  np.zeros([r,c],float)

    super(Cumulative, self).__init__()




  def update_cumulative(self,i,j,surface,subsurface,rain,delta_t):

    self.infiltration[i][j]  += surface.infiltration*self.pixel_area
    self.precipitation[i][j] += rain*self.pixel_area
    self.V_sur[i][j]         += surface.V_runoff
    self.inflow_sur[i][j]    += surface.inflow_tm
    self.sur_ret[i][j]       += surface.cur_sur_ret*self.pixel_area

    q_sheet = surface.V_runoff/delta_t
    q_rill  = surface.V_runoff_rill/delta_t

    if surface.state == 0:
      #jj tu tech ifu musi bet pro kazdej zvlast
      if surface.h > self.h_sur[i][j]:
        self.h_sur[i][j] = surface.h
        self.q_sur[i][j] = q_sheet

    elif (surface.state == 1) or (surface.state == 2):

      self.V_rill[i][j] += surface.V_runoff_rill
      if surface.h > self.h_sur[i][j] :
        self.h_sur[i][j] = surface.h
        self.q_sur[i][j] = q_sheet

      elif surface.h_rill > self.h_rill[i][j]:
        self.h_rill[i][j]  = surface.h_rill
        self.b_rill[i][j]  = surface.b
        self.q_rill[i][j]  = q_rill


    self.update_cumulative_sur(i,j,subsurface.arr[i][j],subsurface.q_subsurface)



















